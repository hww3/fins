import Tools.Logging;

string project;
string config_name = "dev";
array commands;
int overwrite = 0;

// obj->is_resolv_joinnode
// obj->joined_modules[0]->dirname

void create(array args)
{
	int argc;
	
//  Log.set_level(0);
  Log.info("ModelBuilder module loading");

  if(!sizeof(args))
  {
    Log.error("ModelBuilder requires the name of the application to work with.");
    exit(1);
  }

  foreach(Getopt.find_all_options(args,aggregate(
    ({"help",Getopt.NO_ARG,({"--help"}) }),
    ({"config",Getopt.HAS_ARG,({"--config", "-c"}) }),
    ({"force",Getopt.NO_ARG,({"--force", "-f"}) }),
    )),array opt)
    {
      switch(opt[0])
      {
        case "help":
  		  print_help();
		  return 0;
		  break;
        case "config":
          config_name = opt[1];
		  break;
        case "force":
          overwrite ++;
		  break;
	  }
	}

	args-=({0});
	argc = sizeof(args);

  if(argc) project = args[0];

  if(argc>1)
    commands = args[1..];
}

int run()
{
  object ddm;
  object dim;
  string ddmloc;
  string dimloc;

  Log.info("ModelBuilder module running.");

  Fins.Application app = Fins.Loader.load_app(project, config_name);  

  Log.debug("Application loaded.");

  if(!app->model) 
  {
	Log.error("You cannot run ModelBuilder without a model.");
	return 1;
  }

  if(!app->model->repository->get_model_module())
  {
	Log.error("No datatype definition module specified.");
	return 1;	
  }
  else
    ddm = app->model->repository->get_model_module();

  if(!app->model->repository->get_object_module())
  {
	Log.warn("No datatype instance module specified, so we won't work with that.");
//	return 1;	
  }
  else
    dim = app->model->repository->get_object_module();

  Log.debug("Model is connected to " + app->model->context->sql_url + ".");
  Log.debug("Checking Model module directories.");

  // okay, first, let's see if the two modules are directories.
  ddmloc = Fins.Util.get_path_for_module(ddm);
  if(!ddmloc || !file_stat(ddmloc)->isdir || (ddmloc/"/")[-1] == "module.pmod")
  {
	Log.error("Datatype definition module is not a directory. We can't continue.");
    return 1;
  }
  else Log.debug("Datatype definition classes will be stored in " + ddmloc);

  if(dim)
  {
    dimloc = Fins.Util.get_path_for_module(dim);
    if(!ddmloc || !file_stat(ddmloc)->isdir || (ddmloc/"/")[-1] == "module.pmod")
    {
	  Log.error("Datatype instance module is not a directory. We can't continue.");
      return 1;
    }
    else Log.debug("Datatype instance classes will be stored in " + dimloc);
  }

  if(!commands) 
  {
	Log.error("Error: no command given.");
        print_help();
	return 1;
  }

  if(commands[0] != "add")
  {
	Log.error("Error: bad command " + commands[0] + " given.");
        print_help();
	return 1;
  }

  if(sizeof(commands) < 2)
  {
	Log.error("Error: no tables given.");
        print_help();
	return 1;
  }
  
  int errorout;

  foreach(commands[1..]; int i; string t)
  {
    array x = app->model->context->sql->list_tables(t);
    if(!sizeof(x))
    {
	  Log.error("Table \"" + t + "\" does not exist.");
      errorout++;	
    }
  }

  if(errorout)
  {
	Log.error("Aborting due to missing tables.");
	return 1;
  }

  // okay, by this point, we should have valid tables.
  string reponame = sprintf("%O", app->model->repository);
  if(app->model->repository != master()->resolv(reponame))
  {
    Log.error("You're either not using a module for your repository, or you're playing sprintf() games, aren't you?");
    return 1;
    /*
	reponame = Fins.Util.get_path_for_program(object_program(app->model->repository));
	if(!reponame)
	{
      Log.error("uh-oh, you're either not using a module for data storage, or you're playing sprintf() games, aren't you?");
    }
    foreach(master()->pike_program_path;; string p)
	{
		if(has_prefix(reponame, p))
		  reponame = reponame[sizeof(p)+1..];
	}
    reponame = "(object)\"" + reponame + "\"";
    */
  }
  Log.debug("Repository is " + reponame + ".");

  foreach(commands[1..]; int i; string t)
  {
  // first, we figure out what the object should be called.
    string objname = Tools.Language.Inflect.singularize(t);
    objname = String.capitalize(objname);
    Log.debug("Creating objects for data type " + objname + ", sourced from table " + t + ".");

    string ddc = "// auto-generated by Fins.AdminTools.ModelBuilder for table " + t + ".\n\ninherit Fins.Model.DataObject;\n\n"
				 "void post_define()\n{\n// Add any post configuration logic here\n\n// set_alternate_key(\"myalternatekey\");\n\n}\n\n";
    string dic = "// auto-generated by Fins.AdminTools.ModelBuilder.\n\ninherit Fins.Model.DirectAccessInstance;\n"
	             "object repository = " + reponame + ";\n"
	             "string type_name = \"" + objname + "\";\n\n";

    string fn = combine_path(ddmloc, objname + ".pike");
    if(file_stat(fn) && !overwrite)
      Log.warn("file " + fn + " already exists... skipping.");
    else
    {
      Stdio.write_file(fn, ddc);
      Log.info("Wrote new data definition class " + fn + ".");
    }
	fn = combine_path(dimloc, objname + ".pike");
    if(file_stat(fn) && !overwrite)
      Log.warn("file " + fn + " already exists... skipping.");
	else
    {
      Stdio.write_file(fn, dic);
      Log.info("Wrote new data instance class " + fn + ".");
    }
  }

  return 0;
}

void print_help()
{
	werror("Usage: pike -x fins model [-f|--force] [-c config] AppDir add table [table1... tableN]\n");
	return;
}
